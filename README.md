# Lab1
1. Задача 1: Добавление новой сущности "Призрак"
Если мы используем монолитный класс (God Class), то:
Придётся добавить новое поле CanFly (или метод Fly() внутри GameEntity).
Придётся расширить метод Fly(), проверяя условие if (CanFly).
Нужно будет везде учитывать, что призрак не имеет здоровья → добавить дополнительные проверки в TakeDamage(), чтобы у Призрака не отнималось здоровье.
Также потребуется изменить метод Attack(), потому что Призрак может атаковать, хотя у него нет здоровья.
То есть: изменяется и сам базовый класс, и логика поведения. Каждое новое свойство ломает старый код. Это очень затратный процесс.

2. Задача 2: Иерархия наследования
Построить «идеальную» иерархию не получилось:
Дублирование кода: метод Attack() нужен и у Player, и у Zombie, но они находятся в разных ветках (TalkableCharacter и AttackingCharacter). Приходится либо дублировать, либо переносить в общий базовый класс (что приводит к появлению CanAttack).
Странные решения: Loader может говорить, но не атакует; Zombie наоборот атакует, но не говорит. Это приводит к усложнённой иерархии, где появляются искусственные промежуточные классы.
Алмаз смерти (diamond problem): если пытаться объединить поведение через множественное наследование, появляются конфликты методов и необходимость в виртуальных базовых классах.
Итого: иерархия слишком усложняется, а код всё равно становится запутанным.

3. Сравнение двух подходов
Монолитный класс: проще начать, но быстро превращается в кашу из if и флагов. Добавление нового поведения ломает старый код.
Наследование: позволяет описывать базовые сущности лучше, чем God Class, но при усложнении проекта появляются дублирование, странные промежуточные классы и конфликты.
Вывод: для небольших примеров наследование кажется более понятным, но оба подхода плохо масштабируются.

5. Масштабирование до 50 типов сущностей
Монолитный класс:
Будет огромный список флагов (CanTalk, CanMove, CanFly, CanSwim, …).
Методы превратятся в длинные конструкции if-else.
Любое изменение будет ломать весь проект (эффект домино).
Наследование:
Иерархия классов станет слишком глубокой и запутанной.
Появится дублирование кода (например, разные сущности умеют атаковать, но находятся в разных ветках).
Придётся создавать искусственные промежуточные классы, чтобы «втиснуть» поведение.

Вывод: оба подхода имеют серьёзные проблемы поддержки. Это подводит к третьему варианту — композиции (Entity-Component System, ECS), где сущность собирается из компонентов (HealthComponent, AttackComponent, TalkComponent, MovementComponent и т.д.).
